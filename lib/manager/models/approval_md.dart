import 'contract_md.dart';class ApprovalMd {  List? releasable;  List? acknowledgeAble;  String? published;  String? openShift;  List? swapRequests;  List? pendingRequests;  List<ApprovalPendingUserQlf> pendingUserQualifications;  List<ApprovalRequest> requests;  List? problems;  ApprovalMd({    this.releasable,    this.acknowledgeAble,    this.published,    this.openShift,    this.swapRequests,    this.pendingRequests,    required this.pendingUserQualifications,    required this.requests,    this.problems,  });  factory ApprovalMd.fromJson(Map<String, dynamic> json) {    try {      return ApprovalMd(        releasable: json['releasable'],        acknowledgeAble: json['acknowledgeAble'],        published: json['published'],        openShift: json['openShift'],        swapRequests: json['swap_requests'],        pendingRequests: json['pending_requests'],        pendingUserQualifications: List<ApprovalPendingUserQlf>.from(            json['pending_user_qualifications']                .map((x) => ApprovalPendingUserQlf.fromJson(x))),        requests: List<ApprovalRequest>.from(            json['requests'].map((x) => ApprovalRequest.fromJson(x))),        problems: json['problems'],      );    } on TypeError catch (e) {      print('ApprovalMd.fromJson: ${e.stackTrace}');      rethrow;    }  }  Map<String, dynamic> toJson() {    return {      'releasable': releasable,      'acknowledgeAble': acknowledgeAble,      'published': published,      'openShift': openShift,      'swap_requests': swapRequests,      'pending_requests': pendingRequests,      'pending_user_qualifications':          List<dynamic>.from(pendingUserQualifications.map((x) => x.toJson())),      'requests': List<dynamic>.from(requests.map((x) => x.toJson())),      'problems': problems,    };  }  factory ApprovalMd.all() {    return ApprovalMd(      releasable: [],      acknowledgeAble: [],      published: '',      openShift: '',      swapRequests: [],      pendingRequests: [],      pendingUserQualifications: [],      requests: [],      problems: [],    );  }  @override  String toString() {    return 'ApprovalMd{releasable: $releasable, acknowledgeAble: $acknowledgeAble, published: $published, openShift: $openShift, swapRequests: $swapRequests, pendingRequests: $pendingRequests, pendingUserQualifications: $pendingUserQualifications, requests: $requests, problems: $problems}';  }  @override  bool operator ==(Object other) =>      identical(this, other) ||      other is ApprovalMd &&          runtimeType == other.runtimeType &&          releasable == other.releasable &&          acknowledgeAble == other.acknowledgeAble &&          published == other.published &&          openShift == other.openShift &&          swapRequests == other.swapRequests &&          pendingRequests == other.pendingRequests &&          pendingUserQualifications == other.pendingUserQualifications &&          requests == other.requests &&          problems == other.problems;  @override  int get hashCode =>      releasable.hashCode ^      acknowledgeAble.hashCode ^      published.hashCode ^      openShift.hashCode ^      swapRequests.hashCode ^      pendingRequests.hashCode ^      pendingUserQualifications.hashCode ^      requests.hashCode ^      problems.hashCode;}class ApprovalPendingUserQlf {  final int id;  final int qualificationId;  final int userId;  String? title;  String? level;  String? qualComment;  String? comments;  ContractDate? achievementDate;  ContractDate? expiryDate;  String? certificateNumber;  int? createdBy;  String? imageType;  ContractDate? createdOn;  String? fullname;  ApprovalPendingUserQlf({    required this.id,    required this.qualificationId,    required this.userId,    this.title,    this.level,    this.qualComment,    this.comments,    this.achievementDate,    this.expiryDate,    this.certificateNumber,    this.createdBy,    this.imageType,    this.createdOn,    this.fullname,  });  factory ApprovalPendingUserQlf.fromJson(Map<String, dynamic> json) {    try {      return ApprovalPendingUserQlf(        id: json['id'],        qualificationId: json['qualificationId'],        userId: json['userId'],        title: json['title'],        level: json['level'],        qualComment: json['qualComment'],        comments: json['comments'],        achievementDate: ContractDate.fromJson(json['achievementDate']),        expiryDate: json['expiryDate'] == null            ? null            : ContractDate.fromJson(json['expiryDate']),        certificateNumber: json['certificateNumber'],        createdBy: json['createdBy'],        imageType: json['imageType'],        createdOn: json['createdOn'] == null            ? null            : ContractDate.fromJson(json['createdOn']),        fullname: json['fullname'],      );    } on TypeError catch (e) {      print('ApprovalPendingUserQlf.fromJson: ${e.stackTrace}');      rethrow;    }  }  Map<String, dynamic> toJson() {    return {      'id': id,      'qualificationId': qualificationId,      'userId': userId,      'title': title,      'level': level,      'qualComment': qualComment,      'comments': comments,      'achievementDate': achievementDate,      'expiryDate': expiryDate,      'certificateNumber': certificateNumber,      'createdBy': createdBy,      'imageType': imageType,      'createdOn': createdOn,      'fullname': fullname,    };  }  @override  String toString() {    return 'ApprovalPendingUserQlf{id: $id, qualificationId: $qualificationId, userId: $userId, title: $title, level: $level, qualComment: $qualComment, comments: $comments, achievementDate: $achievementDate, expiryDate: $expiryDate, certificateNumber: $certificateNumber, createdBy: $createdBy, imageType: $imageType, createdOn: $createdOn, fullname: $fullname}';  }  @override  bool operator ==(Object other) =>      identical(this, other) ||      other is ApprovalPendingUserQlf &&          runtimeType == other.runtimeType &&          id == other.id &&          qualificationId == other.qualificationId &&          userId == other.userId &&          title == other.title &&          level == other.level &&          qualComment == other.qualComment &&          comments == other.comments &&          achievementDate == other.achievementDate &&          expiryDate == other.expiryDate &&          certificateNumber == other.certificateNumber &&          createdBy == other.createdBy &&          imageType == other.imageType &&          createdOn == other.createdOn &&          fullname == other.fullname;  @override  int get hashCode =>      id.hashCode ^      qualificationId.hashCode ^      userId.hashCode ^      title.hashCode ^      level.hashCode ^      qualComment.hashCode ^      comments.hashCode ^      achievementDate.hashCode ^      expiryDate.hashCode ^      certificateNumber.hashCode ^      createdBy.hashCode ^      imageType.hashCode ^      createdOn.hashCode ^      fullname.hashCode;}class ApprovalRequest {  final int id;  String? typeId;  ContractDate? start;  ContractDate? finish;  String? comment;  String? createdBy;  ContractDate? createdOn;  String? title;  String? firstName;  String? lastName;  String? locationId;  String? groupId;  ApprovalRequest({    required this.id,    required this.typeId,    this.start,    this.finish,    this.comment,    this.createdBy,    this.createdOn,    this.title,    this.firstName,    this.lastName,    this.locationId,    this.groupId,  });  factory ApprovalRequest.fromJson(Map<String, dynamic> json) {    try {      return ApprovalRequest(          id: json['id'],          typeId: json['typeId'],          start: json['start'] == null              ? null              : ContractDate.fromJson(json['start']),          finish: json['finish'] == null              ? null              : ContractDate.fromJson(json['finish']),          comment: json['comment'],          createdBy: json['createdBy'],          createdOn: json['createdOn'] == null              ? null              : ContractDate.fromJson(json['createdOn']),          title: json['title'],          firstName: json['firstName'],          lastName: json['lastName'],          locationId: json['locationId'],          groupId: json['groupId']);    } on TypeError catch (e) {      print('ApprovalRequest.fromJson: ${e.stackTrace}');      rethrow;    }  }  @override  String toString() {    return 'ApprovalRequest{id: $id, typeId: $typeId, start: $start, finish: $finish, comment: $comment, createdBy: $createdBy, createdOn: $createdOn, title: $title, firstName: $firstName, lastName: $lastName, locationId: $locationId, groupId: $groupId}';  }  Map<String, dynamic> toJson() {    return {      'id': id,      'typeId': typeId,      'start': start,      'finish': finish,      'comment': comment,      'createdBy': createdBy,      'createdOn': createdOn,      'title': title,      'firstName': firstName,      'lastName': lastName,      'locationId': locationId,      'groupId': groupId,    };  }  @override  bool operator ==(Object other) =>      identical(this, other) ||      other is ApprovalRequest &&          runtimeType == other.runtimeType &&          id == other.id &&          typeId == other.typeId &&          start == other.start &&          finish == other.finish &&          comment == other.comment &&          createdBy == other.createdBy &&          createdOn == other.createdOn &&          title == other.title &&          firstName == other.firstName &&          lastName == other.lastName &&          locationId == other.locationId &&          groupId == other.groupId;  @override  int get hashCode =>      id.hashCode ^      typeId.hashCode ^      start.hashCode ^      finish.hashCode ^      comment.hashCode ^      createdBy.hashCode ^      createdOn.hashCode ^      title.hashCode ^      firstName.hashCode ^      lastName.hashCode ^      locationId.hashCode ^      groupId.hashCode;}